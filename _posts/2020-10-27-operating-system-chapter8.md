---
layout: post
title: "[운영체제] System Structure & Program Execution 1"
author: Jungeun
categories: [operating-system]
tags: [OS, 반효경 교수님 강의]
description: "컴퓨터 시스템 구조, Mode bit, Timer, Device Controller, 입출력(I/O)의 수행, 동기식 입출력과 비동기식 입출력, 시스템콜(System Call), 인터럽트(Interrupt)"
featured: false
---

> 컴퓨터 시스템에서 하드웨어가 어떻게 동작하는 지 컴퓨터 프로그램들이 하드웨어를 위해서 어떻게 돌아가는 지 에 대한 설명

1. 컴퓨터 시스템 구조

   - CPU - cpu 는 매 클럭 사이클 마다 메모리에서 인스트럭션을 하나씩 읽어 실행한다. 

     mode bit - cpu 에서 실행되는 것이 운영체제인지 사용자인지 구분

     registers - 메모리 보다 빠르면서 정보를 저장하는 공간

     interrupt line - cpu 는 항상 메모리에서 인스트럭션만 읽어 실행한다. 그래서 I/O 디바이스에서 요청이 오면 전달해준다. 인터럽트 라인에 요청이 들어오면 cpu 는 하던 일을 멈추고 cpu 제어권이 사용자 프로그램에서 운영체제로 넘어오게 된다. 그리고 인터럽트 요청을 수행한다.

   - Memory - cpu 의 작업 공간 

   - I/O Device - 키보드, 마우스 (인풋 디바이스) , 프린트, 모니터 (아웃풋 디바이스) , Disk (인풋/아웃풋 디바이스) 각 디바이스들은 디바이스를 전담하는 작은 cpu 같은 device controller 가 존재 한다. 디스크에서 헤더가 어떻게 움직이고 내부에 어떤 데이터를 읽을지 디스크의 내부를 통제하는 것은 디바이스 컨트롤러가 한다. 디바이스의 작업 공간인 local buffer 가 존재한다. 

   - timer - 특정 프로그램이 cpu 를 독점하는 것을 막기 위한 장치 , 사용자 프로그램은 타이머에 할당된 시간 만큼 cpu 를 가질 수 있다. 시간이 지나면 타이머는 인터럽트 라인을 통해 cpu 에게 알려준다. 타이머가 종료 되기 전 프로그램이 끝나면 cpu를 자동 반납한다. 

2. Mode bit

   사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치

   Mode bit 을 통해 하드웨어적 두 가지 모두의 operation 지원

   -  1 : 사용자 모드 - 사용자 프로그램 수행 -> 제한된 명령어만 수행 가능 (I/O접근, 메모리 접근 불가)

   -  0 : 모니터 모드(= 커널 모드, 시스템 모드) - OS 코드 수행 -> 메모리 접근, I/O 접근 등 모든 명령어 수행 가능
     - 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 **특권명령**으로 규정
     - Interrupt 나 Exception 발생시 하드웨어가 mode bit 을 0으로 바꿈
     - 사용자 프로그램에게 CPU를 넘기기 전에 mode bit 을 1로 셋팅

3. Timer

   - 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴
   - 타이머는 매 클럭 틱 때마다 1씩 감소
   - 타이머 값이 0 이 되면 타이머 인터럽트 발생
   - CPU를 특정 프로그램이 독점하는 것으로부터 보호
   - time sharing 을 구현하기 위해 널리 이용됨
   - 현재 시간을 계산하기 위해서도 사용됨

4. Device Controller

   - 해당 I/O 장치 유형을 관리하는 일종의 작은 CPU
   - 제어 정보를 위해 control register, status register 를 가진다.
   - local buffer를 가진다 (일종의 data register) -> 실제 데이터를 담는 부분, 화면에 출력해야할 데이터는 local buffer 에 담고 화면에 출력해라 라는 명령은 control register를 통해 CPU가 디바이스 컨트롤러에 전달.
   - I/O는 실제 디바이스와 local buffer 사이에서 일어난다.
   - Device controller 는 I/O가 끝났을 경우 interrupt 로 CPU에 그 사실을 알린다.

5. DMA Controller

   직접 메모리를 접근할 수 있는 컨트롤러, 원래는 CPU만 메모리에 접근 가능하지만 DMA를 통해 메모리를 접근 할 수 있도록 함.

   너무 잦은 I/O 인터럽트로 인해 CPU가 계속 중단되는 상황으로 오히려 속도가 느려지는 경우가 발생하여 비효율적임 -> I/O 들어오면 I/O는 인터럽트 걸고 CPU는 운영체제로 넘어가서 데이터를 메모리에 복사하는 과정때문

   그래서 DMA를 통해 중간중간 들어오는 I/O 데이터들을 메모리에 쌓아 두어 CPU는 자기가 하던 일을 계속 할 수 있게 해준다. 그리고 I/O데이터들이 메모리에 다 올려지면 CPU에게 알려준다. -> CPU 가 중간에 인터럽트 당하는 빈도가 줄어 듦

   

6. Memory Controller

   DMA 와 CPU 가 공통적인 메모리에 접근하게 된다면 오류가 발생 할 수 있기 때문에 메모리컨트롤러가 누가 먼저 접근하게 할지 조율하는 역할을 한다. 

7. 입출력(I/O)의 수행

   모든 입출력 명령은 특권 명령

   사용자 프로그램은 어떻게 I/O를 하는 가?

   - 시스템 콜(system call) -> 사용자 프로그램이 운영체제에게 부탁하는 것, 사용자 프로그램이 운영체제의 함수를 호출하는 것

     사용자 프로그램은 운영체제에게 I/O 요청

   - trap 을 사용하여 인터럽트 벡터의 특정 위치로 이동

   - 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동

   - 올바른 I/O 요청인지 확인 후 I/O 수행

   - I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김

8. 인터럽트 (Interrupt)

   - 인터럽트 : 인터럽트 당한 시점의 레지스터와 program counter 를 save 한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.
   - Interrupt 종류
     - Interrupt ( 하드웨어 인터럽트 ) : 하드웨어가 발생시킨 인터럽트 -> 타이머, I/O
     - Trap (소프트웨어 인터럽트 ) : Exception 프로그램이 오류를 범한 경우 , System call 프로그램이 커널 함수를 호출하는 경우
   - 인터럽트 관련 용어
     - 인터럽트 백터 :  해당 인터럽트의 처리 루틴 주소를 가지고 있음 -> 타이머 인터럽트는 어떻게 처리하고 I/O는 어떻게 처리하는 지 인터럽트마다 처리 방법이 정해져 있음. 그 인터럽트가 들어오면 어떤 함수를 실행시켜야 하고 그 함수는 어디에 위치해 있는 지 테이블로 정의해 둔 것
     - 인터럽트 처리 루틴 (= Interrupt Service Routine, 인터럽트 핸들러) : 해당 인터럽트를 처리하는 커널 함수

   I/O 요청이 있을 때 두번의 인터럽트가 발생한다.

   1. 사용자 프로그램이 I/O 요청을 위해 OS 에게 시스템 콜을 한다. (소프트웨어 인터럽트)
   2. CPU 는 I/O 에게 요청한 작업을 수행하게 하고 CPU 는 하던 일을 계속 한다.
   3. I/O 는 요청한 일을 다 끝내면 CPU 에게 일을 끝냈다고 인터럽트를 건다. (하드웨어 인터럽트)



*출처: [이화여대 반효경교수님 강의]( http://www.kocw.net/home/search/kemView.do?kemId=1046323)*